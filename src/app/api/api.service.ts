//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

namespace Api {

export class ApiService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(version: string, body: LoginModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/Auth/login";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param symbol (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param interval (optional) 
     * @return OK
     */
    backtesting(symbol: string | undefined, fromDate: Date | undefined, toDate: Date | undefined, interval: string | undefined): Promise<BacktestResultDto> {
        let url_ = this.baseUrl + "/api/Backtesting?";
        if (symbol === null)
            throw new Error("The parameter 'symbol' cannot be null.");
        else if (symbol !== undefined)
            url_ += "symbol=" + encodeURIComponent("" + symbol) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (interval === null)
            throw new Error("The parameter 'interval' cannot be null.");
        else if (interval !== undefined)
            url_ += "interval=" + encodeURIComponent("" + interval) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBacktesting(_response);
        });
    }

    protected processBacktesting(response: Response): Promise<BacktestResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BacktestResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BacktestResultDto>(null as any);
    }

    /**
     * @return OK
     */
    notificationAll(): Promise<NotificationPreference[]> {
        let url_ = this.baseUrl + "/api/Notification";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotificationAll(_response);
        });
    }

    protected processNotificationAll(response: Response): Promise<NotificationPreference[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationPreference.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationPreference[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    notificationPOST(body: NotificationPreference | undefined): Promise<NotificationPreference> {
        let url_ = this.baseUrl + "/api/Notification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotificationPOST(_response);
        });
    }

    protected processNotificationPOST(response: Response): Promise<NotificationPreference> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationPreference.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationPreference>(null as any);
    }

    /**
     * @return OK
     */
    notificationGET(id: string): Promise<NotificationPreference> {
        let url_ = this.baseUrl + "/api/Notification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotificationGET(_response);
        });
    }

    protected processNotificationGET(response: Response): Promise<NotificationPreference> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationPreference.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationPreference>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    notificationPUT(id: string, body: NotificationPreference | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Notification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotificationPUT(_response);
        });
    }

    protected processNotificationPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    notificationDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Notification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotificationDELETE(_response);
        });
    }

    protected processNotificationDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    ordersGET(): Promise<void> {
        let url_ = this.baseUrl + "/api/Orders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersGET(_response);
        });
    }

    protected processOrdersGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    ordersPOST(body: PlaceOrderParams | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersPOST(_response);
        });
    }

    protected processOrdersPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    history(): Promise<void> {
        let url_ = this.baseUrl + "/api/Orders/history";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    ordersPUT(orderId: string, body: ModifyOrderParams | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Orders/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersPUT(_response);
        });
    }

    protected processOrdersPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    ordersDELETE(orderId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Orders/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersDELETE(_response);
        });
    }

    protected processOrdersDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    holdings(): Promise<void> {
        let url_ = this.baseUrl + "/Portfolio/holdings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHoldings(_response);
        });
    }

    protected processHoldings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    positions(): Promise<void> {
        let url_ = this.baseUrl + "/Portfolio/positions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPositions(_response);
        });
    }

    protected processPositions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    pnl(): Promise<PositionPnlDto> {
        let url_ = this.baseUrl + "/Portfolio/pnl";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPnl(_response);
        });
    }

    protected processPnl(response: Response): Promise<PositionPnlDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionPnlDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionPnlDto>(null as any);
    }

    /**
     * @param instruments (optional) 
     * @return OK
     */
    quotes(instruments: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Quotes?";
        if (instruments === null)
            throw new Error("The parameter 'instruments' cannot be null.");
        else if (instruments !== undefined)
            instruments && instruments.forEach(item => { url_ += "instruments=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuotes(_response);
        });
    }

    protected processQuotes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param instrumentToken (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param interval (optional) 
     * @return OK
     */
    historical(instrumentToken: string | undefined, from: Date | undefined, to: Date | undefined, interval: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Quotes/historical?";
        if (instrumentToken === null)
            throw new Error("The parameter 'instrumentToken' cannot be null.");
        else if (instrumentToken !== undefined)
            url_ += "instrumentToken=" + encodeURIComponent("" + instrumentToken) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (interval === null)
            throw new Error("The parameter 'interval' cannot be null.");
        else if (interval !== undefined)
            url_ += "interval=" + encodeURIComponent("" + interval) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistorical(_response);
        });
    }

    protected processHistorical(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    screenerAll(): Promise<ScreenerCriteria[]> {
        let url_ = this.baseUrl + "/api/Screener";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScreenerAll(_response);
        });
    }

    protected processScreenerAll(response: Response): Promise<ScreenerCriteria[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScreenerCriteria.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenerCriteria[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    screenerPOST(body: ScreenerCriteria | undefined): Promise<ScreenerCriteria> {
        let url_ = this.baseUrl + "/api/Screener";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScreenerPOST(_response);
        });
    }

    protected processScreenerPOST(response: Response): Promise<ScreenerCriteria> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenerCriteria.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenerCriteria>(null as any);
    }

    /**
     * @return OK
     */
    screenerGET(id: string): Promise<ScreenerCriteria> {
        let url_ = this.baseUrl + "/api/Screener/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScreenerGET(_response);
        });
    }

    protected processScreenerGET(response: Response): Promise<ScreenerCriteria> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenerCriteria.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenerCriteria>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    screenerPUT(id: string, body: ScreenerCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Screener/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScreenerPUT(_response);
        });
    }

    protected processScreenerPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    screenerDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Screener/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScreenerDELETE(_response);
        });
    }

    protected processScreenerDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    run(id: string): Promise<Instrument[]> {
        let url_ = this.baseUrl + "/api/Screener/run/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: Response): Promise<Instrument[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Instrument.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Instrument[]>(null as any);
    }

    /**
     * @return OK
     */
    strategiesAll(version: string): Promise<Strategy[]> {
        let url_ = this.baseUrl + "/api/v{version}/Strategies";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategiesAll(_response);
        });
    }

    protected processStrategiesAll(response: Response): Promise<Strategy[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Strategy.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Strategy[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    strategiesPOST(version: string, body: Strategy | undefined): Promise<Strategy> {
        let url_ = this.baseUrl + "/api/v{version}/Strategies";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategiesPOST(_response);
        });
    }

    protected processStrategiesPOST(response: Response): Promise<Strategy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Strategy.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Strategy>(null as any);
    }

    /**
     * @return OK
     */
    strategiesGET(id: number, version: string): Promise<Strategy> {
        let url_ = this.baseUrl + "/api/v{version}/Strategies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategiesGET(_response);
        });
    }

    protected processStrategiesGET(response: Response): Promise<Strategy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Strategy.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Strategy>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    strategiesPUT(id: number, version: string, body: Strategy | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/Strategies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategiesPUT(_response);
        });
    }

    protected processStrategiesPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    strategiesDELETE(id: number, version: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/Strategies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategiesDELETE(_response);
        });
    }

    protected processStrategiesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    squareOffAll(strategyId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Strategy/{strategyId}/square-off-all";
        if (strategyId === undefined || strategyId === null)
            throw new Error("The parameter 'strategyId' must be defined.");
        url_ = url_.replace("{strategyId}", encodeURIComponent("" + strategyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSquareOffAll(_response);
        });
    }

    protected processSquareOffAll(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    totalAllocatedCapital(): Promise<number> {
        let url_ = this.baseUrl + "/api/Strategy/total-allocated-capital";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTotalAllocatedCapital(_response);
        });
    }

    protected processTotalAllocatedCapital(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    strategyAll(): Promise<StrategyConfig[]> {
        let url_ = this.baseUrl + "/api/Strategy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategyAll(_response);
        });
    }

    protected processStrategyAll(response: Response): Promise<StrategyConfig[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StrategyConfig.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StrategyConfig[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    strategyPOST(body: StrategyConfig | undefined): Promise<StrategyConfig> {
        let url_ = this.baseUrl + "/api/Strategy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategyPOST(_response);
        });
    }

    protected processStrategyPOST(response: Response): Promise<StrategyConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StrategyConfig.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StrategyConfig>(null as any);
    }

    /**
     * @return OK
     */
    strategyGET(id: string): Promise<StrategyConfig> {
        let url_ = this.baseUrl + "/api/Strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategyGET(_response);
        });
    }

    protected processStrategyGET(response: Response): Promise<StrategyConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StrategyConfig.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StrategyConfig>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    strategyPUT(id: string, body: StrategyConfig | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategyPUT(_response);
        });
    }

    protected processStrategyPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    strategyDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStrategyDELETE(_response);
        });
    }

    protected processStrategyDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    alert(body: TradingViewAlert | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Trading/alert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAlert(_response);
        });
    }

    protected processAlert(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    exitAll(): Promise<void> {
        let url_ = this.baseUrl + "/api/Trading/exit-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExitAll(_response);
        });
    }

    protected processExitAll(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tradingview(body: TradingViewAlert | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Webhook/tradingview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTradingview(_response);
        });
    }

    protected processTradingview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    manualAlerts(): Promise<ManualTradingViewAlert[]> {
        let url_ = this.baseUrl + "/api/Webhook/manual-alerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManualAlerts(_response);
        });
    }

    protected processManualAlerts(response: Response): Promise<ManualTradingViewAlert[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ManualTradingViewAlert.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManualTradingViewAlert[]>(null as any);
    }

    /**
     * @return OK
     */
    executeManualAlert(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Webhook/execute-manual-alert/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteManualAlert(_response);
        });
    }

    protected processExecuteManualAlert(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BacktestResultDto implements IBacktestResultDto {
    symbol!: string | undefined;
    fromDate?: Date;
    toDate?: Date;
    interval!: string | undefined;
    totalProfitLoss?: number;
    totalTrades?: number;
    winningTrades?: number;
    losingTrades?: number;
    winRate?: number;
    maxDrawdown?: number;
    simulatedTrades?: SimulatedTrade[] | undefined;

    constructor(data?: IBacktestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.interval = _data["interval"];
            this.totalProfitLoss = _data["totalProfitLoss"];
            this.totalTrades = _data["totalTrades"];
            this.winningTrades = _data["winningTrades"];
            this.losingTrades = _data["losingTrades"];
            this.winRate = _data["winRate"];
            this.maxDrawdown = _data["maxDrawdown"];
            if (Array.isArray(_data["simulatedTrades"])) {
                this.simulatedTrades = [] as any;
                for (let item of _data["simulatedTrades"])
                    this.simulatedTrades!.push(SimulatedTrade.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BacktestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BacktestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["interval"] = this.interval;
        data["totalProfitLoss"] = this.totalProfitLoss;
        data["totalTrades"] = this.totalTrades;
        data["winningTrades"] = this.winningTrades;
        data["losingTrades"] = this.losingTrades;
        data["winRate"] = this.winRate;
        data["maxDrawdown"] = this.maxDrawdown;
        if (Array.isArray(this.simulatedTrades)) {
            data["simulatedTrades"] = [];
            for (let item of this.simulatedTrades)
                data["simulatedTrades"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IBacktestResultDto {
    symbol: string | undefined;
    fromDate?: Date;
    toDate?: Date;
    interval: string | undefined;
    totalProfitLoss?: number;
    totalTrades?: number;
    winningTrades?: number;
    losingTrades?: number;
    winRate?: number;
    maxDrawdown?: number;
    simulatedTrades?: SimulatedTrade[] | undefined;
}

export class BrokerLevelSettings implements IBrokerLevelSettings {
    id?: number;
    strategyId!: number;
    strategy?: Strategy;
    overallStopLoss?: number | undefined;
    overallTarget?: number | undefined;
    incrementProfitBy?: number | undefined;
    trailSLBy?: number | undefined;
    lockProfitAt?: number | undefined;
    minimumProfitToLock?: number | undefined;

    constructor(data?: IBrokerLevelSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.strategyId = _data["strategyId"];
            this.strategy = _data["strategy"] ? Strategy.fromJS(_data["strategy"]) : <any>undefined;
            this.overallStopLoss = _data["overallStopLoss"];
            this.overallTarget = _data["overallTarget"];
            this.incrementProfitBy = _data["incrementProfitBy"];
            this.trailSLBy = _data["trailSLBy"];
            this.lockProfitAt = _data["lockProfitAt"];
            this.minimumProfitToLock = _data["minimumProfitToLock"];
        }
    }

    static fromJS(data: any): BrokerLevelSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BrokerLevelSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["strategyId"] = this.strategyId;
        data["strategy"] = this.strategy ? this.strategy.toJSON() : <any>undefined;
        data["overallStopLoss"] = this.overallStopLoss;
        data["overallTarget"] = this.overallTarget;
        data["incrementProfitBy"] = this.incrementProfitBy;
        data["trailSLBy"] = this.trailSLBy;
        data["lockProfitAt"] = this.lockProfitAt;
        data["minimumProfitToLock"] = this.minimumProfitToLock;
        return data;
    }
}

export interface IBrokerLevelSettings {
    id?: number;
    strategyId: number;
    strategy?: Strategy;
    overallStopLoss?: number | undefined;
    overallTarget?: number | undefined;
    incrementProfitBy?: number | undefined;
    trailSLBy?: number | undefined;
    lockProfitAt?: number | undefined;
    minimumProfitToLock?: number | undefined;
}

export class ExecutionSettings implements IExecutionSettings {
    id?: number;
    strategyId!: number;
    strategy?: Strategy;
    entryTime!: string;
    exitTime!: string;
    productType!: ProductType;
    entryOrderType!: OrderType;
    exitOrderType!: OrderType;
    limitBuffer?: number | undefined;
    targetSLRefPrice!: TargetSLRefPrice;
    quantityMultiplier?: number;
    delayEntryBySeconds?: number;
    tradingDays?: string | undefined;
    autoSquareoff?: boolean;

    constructor(data?: IExecutionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.strategyId = _data["strategyId"];
            this.strategy = _data["strategy"] ? Strategy.fromJS(_data["strategy"]) : <any>undefined;
            this.entryTime = _data["entryTime"];
            this.exitTime = _data["exitTime"];
            this.productType = _data["productType"];
            this.entryOrderType = _data["entryOrderType"];
            this.exitOrderType = _data["exitOrderType"];
            this.limitBuffer = _data["limitBuffer"];
            this.targetSLRefPrice = _data["targetSLRefPrice"];
            this.quantityMultiplier = _data["quantityMultiplier"];
            this.delayEntryBySeconds = _data["delayEntryBySeconds"];
            this.tradingDays = _data["tradingDays"];
            this.autoSquareoff = _data["autoSquareoff"];
        }
    }

    static fromJS(data: any): ExecutionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ExecutionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["strategyId"] = this.strategyId;
        data["strategy"] = this.strategy ? this.strategy.toJSON() : <any>undefined;
        data["entryTime"] = this.entryTime;
        data["exitTime"] = this.exitTime;
        data["productType"] = this.productType;
        data["entryOrderType"] = this.entryOrderType;
        data["exitOrderType"] = this.exitOrderType;
        data["limitBuffer"] = this.limitBuffer;
        data["targetSLRefPrice"] = this.targetSLRefPrice;
        data["quantityMultiplier"] = this.quantityMultiplier;
        data["delayEntryBySeconds"] = this.delayEntryBySeconds;
        data["tradingDays"] = this.tradingDays;
        data["autoSquareoff"] = this.autoSquareoff;
        return data;
    }
}

export interface IExecutionSettings {
    id?: number;
    strategyId: number;
    strategy?: Strategy;
    entryTime: string;
    exitTime: string;
    productType: ProductType;
    entryOrderType: OrderType;
    exitOrderType: OrderType;
    limitBuffer?: number | undefined;
    targetSLRefPrice: TargetSLRefPrice;
    quantityMultiplier?: number;
    delayEntryBySeconds?: number;
    tradingDays?: string | undefined;
    autoSquareoff?: boolean;
}

export class Instrument implements IInstrument {
    instrumentToken?: number;
    exchangeToken?: number;
    tradingSymbol?: string | undefined;
    name?: string | undefined;
    lastPrice?: number;
    tickSize?: number;
    expiry?: Date | undefined;
    instrumentType?: string | undefined;
    segment?: string | undefined;
    exchange?: string | undefined;
    strike?: number;
    lotSize?: number;

    constructor(data?: IInstrument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.instrumentToken = _data["instrumentToken"];
            this.exchangeToken = _data["exchangeToken"];
            this.tradingSymbol = _data["tradingSymbol"];
            this.name = _data["name"];
            this.lastPrice = _data["lastPrice"];
            this.tickSize = _data["tickSize"];
            this.expiry = _data["expiry"] ? new Date(_data["expiry"].toString()) : <any>undefined;
            this.instrumentType = _data["instrumentType"];
            this.segment = _data["segment"];
            this.exchange = _data["exchange"];
            this.strike = _data["strike"];
            this.lotSize = _data["lotSize"];
        }
    }

    static fromJS(data: any): Instrument {
        data = typeof data === 'object' ? data : {};
        let result = new Instrument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instrumentToken"] = this.instrumentToken;
        data["exchangeToken"] = this.exchangeToken;
        data["tradingSymbol"] = this.tradingSymbol;
        data["name"] = this.name;
        data["lastPrice"] = this.lastPrice;
        data["tickSize"] = this.tickSize;
        data["expiry"] = this.expiry ? this.expiry.toISOString() : <any>undefined;
        data["instrumentType"] = this.instrumentType;
        data["segment"] = this.segment;
        data["exchange"] = this.exchange;
        data["strike"] = this.strike;
        data["lotSize"] = this.lotSize;
        return data;
    }
}

export interface IInstrument {
    instrumentToken?: number;
    exchangeToken?: number;
    tradingSymbol?: string | undefined;
    name?: string | undefined;
    lastPrice?: number;
    tickSize?: number;
    expiry?: Date | undefined;
    instrumentType?: string | undefined;
    segment?: string | undefined;
    exchange?: string | undefined;
    strike?: number;
    lotSize?: number;
}

export class Leg implements ILeg {
    id?: number;
    strategyId!: number;
    strategy?: Strategy;
    underlyingAsset!: string;
    expiryDate!: Date;
    strikePrice?: number;
    optionType!: OptionType;
    position!: Position;
    quantityLots!: number;

    constructor(data?: ILeg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.strategyId = _data["strategyId"];
            this.strategy = _data["strategy"] ? Strategy.fromJS(_data["strategy"]) : <any>undefined;
            this.underlyingAsset = _data["underlyingAsset"];
            this.expiryDate = _data["expiryDate"] ? new Date(_data["expiryDate"].toString()) : <any>undefined;
            this.strikePrice = _data["strikePrice"];
            this.optionType = _data["optionType"];
            this.position = _data["position"];
            this.quantityLots = _data["quantityLots"];
        }
    }

    static fromJS(data: any): Leg {
        data = typeof data === 'object' ? data : {};
        let result = new Leg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["strategyId"] = this.strategyId;
        data["strategy"] = this.strategy ? this.strategy.toJSON() : <any>undefined;
        data["underlyingAsset"] = this.underlyingAsset;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["strikePrice"] = this.strikePrice;
        data["optionType"] = this.optionType;
        data["position"] = this.position;
        data["quantityLots"] = this.quantityLots;
        return data;
    }
}

export interface ILeg {
    id?: number;
    strategyId: number;
    strategy?: Strategy;
    underlyingAsset: string;
    expiryDate: Date;
    strikePrice?: number;
    optionType: OptionType;
    position: Position;
    quantityLots: number;
}

export class LoginModel implements ILoginModel {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginModel {
    username?: string | undefined;
    password?: string | undefined;
}

export class ManualTradingViewAlert implements IManualTradingViewAlert {
    id?: string | undefined;
    strategyName?: string | undefined;
    strike?: number;
    type?: string | undefined;
    signal?: string | undefined;
    action?: string | undefined;
    receivedTime?: Date;
    isExecuted?: boolean;

    constructor(data?: IManualTradingViewAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.strategyName = _data["strategyName"];
            this.strike = _data["strike"];
            this.type = _data["type"];
            this.signal = _data["signal"];
            this.action = _data["action"];
            this.receivedTime = _data["receivedTime"] ? new Date(_data["receivedTime"].toString()) : <any>undefined;
            this.isExecuted = _data["isExecuted"];
        }
    }

    static fromJS(data: any): ManualTradingViewAlert {
        data = typeof data === 'object' ? data : {};
        let result = new ManualTradingViewAlert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["strategyName"] = this.strategyName;
        data["strike"] = this.strike;
        data["type"] = this.type;
        data["signal"] = this.signal;
        data["action"] = this.action;
        data["receivedTime"] = this.receivedTime ? this.receivedTime.toISOString() : <any>undefined;
        data["isExecuted"] = this.isExecuted;
        return data;
    }
}

export interface IManualTradingViewAlert {
    id?: string | undefined;
    strategyName?: string | undefined;
    strike?: number;
    type?: string | undefined;
    signal?: string | undefined;
    action?: string | undefined;
    receivedTime?: Date;
    isExecuted?: boolean;
}

export class ModifyOrderParams implements IModifyOrderParams {
    quantity?: number | undefined;
    price?: number | undefined;
    triggerPrice?: number | undefined;
    orderType?: string | undefined;

    constructor(data?: IModifyOrderParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.triggerPrice = _data["triggerPrice"];
            this.orderType = _data["orderType"];
        }
    }

    static fromJS(data: any): ModifyOrderParams {
        data = typeof data === 'object' ? data : {};
        let result = new ModifyOrderParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["triggerPrice"] = this.triggerPrice;
        data["orderType"] = this.orderType;
        return data;
    }
}

export interface IModifyOrderParams {
    quantity?: number | undefined;
    price?: number | undefined;
    triggerPrice?: number | undefined;
    orderType?: string | undefined;
}

export enum NotificationChannel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class NotificationPreference implements INotificationPreference {
    id?: string | undefined;
    userId!: string | undefined;
    channel?: NotificationChannel;
    destination!: string | undefined;
    isActive?: boolean;
    eventTypes?: string[] | undefined;

    constructor(data?: INotificationPreference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.channel = _data["channel"];
            this.destination = _data["destination"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["eventTypes"])) {
                this.eventTypes = [] as any;
                for (let item of _data["eventTypes"])
                    this.eventTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationPreference {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationPreference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["channel"] = this.channel;
        data["destination"] = this.destination;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.eventTypes)) {
            data["eventTypes"] = [];
            for (let item of this.eventTypes)
                data["eventTypes"].push(item);
        }
        return data;
    }
}

export interface INotificationPreference {
    id?: string | undefined;
    userId: string | undefined;
    channel?: NotificationChannel;
    destination: string | undefined;
    isActive?: boolean;
    eventTypes?: string[] | undefined;
}

export enum OptionType {
    _0 = 0,
    _1 = 1,
}

export enum OrderType {
    _0 = 0,
    _1 = 1,
}

export class PlaceOrderParams implements IPlaceOrderParams {
    exchange?: string | undefined;
    tradingSymbol?: string | undefined;
    transactionType?: string | undefined;
    quantity?: number;
    product?: string | undefined;
    orderType?: string | undefined;
    price?: number | undefined;

    constructor(data?: IPlaceOrderParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exchange = _data["exchange"];
            this.tradingSymbol = _data["tradingSymbol"];
            this.transactionType = _data["transactionType"];
            this.quantity = _data["quantity"];
            this.product = _data["product"];
            this.orderType = _data["orderType"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): PlaceOrderParams {
        data = typeof data === 'object' ? data : {};
        let result = new PlaceOrderParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exchange"] = this.exchange;
        data["tradingSymbol"] = this.tradingSymbol;
        data["transactionType"] = this.transactionType;
        data["quantity"] = this.quantity;
        data["product"] = this.product;
        data["orderType"] = this.orderType;
        data["price"] = this.price;
        return data;
    }
}

export interface IPlaceOrderParams {
    exchange?: string | undefined;
    tradingSymbol?: string | undefined;
    transactionType?: string | undefined;
    quantity?: number;
    product?: string | undefined;
    orderType?: string | undefined;
    price?: number | undefined;
}

export enum Position {
    _0 = 0,
    _1 = 1,
}

export class PositionPnlDto implements IPositionPnlDto {
    totalRealizedPnl?: number;
    totalUnrealizedPnl?: number;
    overallPnl?: number;

    constructor(data?: IPositionPnlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRealizedPnl = _data["totalRealizedPnl"];
            this.totalUnrealizedPnl = _data["totalUnrealizedPnl"];
            this.overallPnl = _data["overallPnl"];
        }
    }

    static fromJS(data: any): PositionPnlDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionPnlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRealizedPnl"] = this.totalRealizedPnl;
        data["totalUnrealizedPnl"] = this.totalUnrealizedPnl;
        data["overallPnl"] = this.overallPnl;
        return data;
    }
}

export interface IPositionPnlDto {
    totalRealizedPnl?: number;
    totalUnrealizedPnl?: number;
    overallPnl?: number;
}

export enum ProductType {
    _0 = 0,
    _1 = 1,
}

export class RiskParameters implements IRiskParameters {
    maxOpenPositions?: number;
    maxExposure?: number;
    maxLoss?: number;
    maxProfit?: number;

    constructor(data?: IRiskParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxOpenPositions = _data["maxOpenPositions"];
            this.maxExposure = _data["maxExposure"];
            this.maxLoss = _data["maxLoss"];
            this.maxProfit = _data["maxProfit"];
        }
    }

    static fromJS(data: any): RiskParameters {
        data = typeof data === 'object' ? data : {};
        let result = new RiskParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxOpenPositions"] = this.maxOpenPositions;
        data["maxExposure"] = this.maxExposure;
        data["maxLoss"] = this.maxLoss;
        data["maxProfit"] = this.maxProfit;
        return data;
    }
}

export interface IRiskParameters {
    maxOpenPositions?: number;
    maxExposure?: number;
    maxLoss?: number;
    maxProfit?: number;
}

export class ScreenerCriteria implements IScreenerCriteria {
    id?: string | undefined;
    name!: string | undefined;
    exchange!: string | undefined;
    instrumentType!: string | undefined;
    minPrice?: number | undefined;
    maxPrice?: number | undefined;
    minVolume?: number | undefined;
    maxVolume?: number | undefined;
    technicalIndicators?: { [key: string]: string; } | undefined;
    watchlistSymbols?: string[] | undefined;

    constructor(data?: IScreenerCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.exchange = _data["exchange"];
            this.instrumentType = _data["instrumentType"];
            this.minPrice = _data["minPrice"];
            this.maxPrice = _data["maxPrice"];
            this.minVolume = _data["minVolume"];
            this.maxVolume = _data["maxVolume"];
            if (_data["technicalIndicators"]) {
                this.technicalIndicators = {} as any;
                for (let key in _data["technicalIndicators"]) {
                    if (_data["technicalIndicators"].hasOwnProperty(key))
                        (<any>this.technicalIndicators)![key] = _data["technicalIndicators"][key];
                }
            }
            if (Array.isArray(_data["watchlistSymbols"])) {
                this.watchlistSymbols = [] as any;
                for (let item of _data["watchlistSymbols"])
                    this.watchlistSymbols!.push(item);
            }
        }
    }

    static fromJS(data: any): ScreenerCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenerCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["exchange"] = this.exchange;
        data["instrumentType"] = this.instrumentType;
        data["minPrice"] = this.minPrice;
        data["maxPrice"] = this.maxPrice;
        data["minVolume"] = this.minVolume;
        data["maxVolume"] = this.maxVolume;
        if (this.technicalIndicators) {
            data["technicalIndicators"] = {};
            for (let key in this.technicalIndicators) {
                if (this.technicalIndicators.hasOwnProperty(key))
                    (<any>data["technicalIndicators"])[key] = (<any>this.technicalIndicators)[key];
            }
        }
        if (Array.isArray(this.watchlistSymbols)) {
            data["watchlistSymbols"] = [];
            for (let item of this.watchlistSymbols)
                data["watchlistSymbols"].push(item);
        }
        return data;
    }
}

export interface IScreenerCriteria {
    id?: string | undefined;
    name: string | undefined;
    exchange: string | undefined;
    instrumentType: string | undefined;
    minPrice?: number | undefined;
    maxPrice?: number | undefined;
    minVolume?: number | undefined;
    maxVolume?: number | undefined;
    technicalIndicators?: { [key: string]: string; } | undefined;
    watchlistSymbols?: string[] | undefined;
}

export class SimulatedTrade implements ISimulatedTrade {
    orderId!: string | undefined;
    tradingSymbol!: string | undefined;
    transactionType!: string | undefined;
    quantity?: number;
    entryPrice?: number;
    entryTime?: Date;
    exitPrice?: number;
    exitTime?: Date;
    profitLoss?: number;
    status!: string | undefined;

    constructor(data?: ISimulatedTrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.tradingSymbol = _data["tradingSymbol"];
            this.transactionType = _data["transactionType"];
            this.quantity = _data["quantity"];
            this.entryPrice = _data["entryPrice"];
            this.entryTime = _data["entryTime"] ? new Date(_data["entryTime"].toString()) : <any>undefined;
            this.exitPrice = _data["exitPrice"];
            this.exitTime = _data["exitTime"] ? new Date(_data["exitTime"].toString()) : <any>undefined;
            this.profitLoss = _data["profitLoss"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SimulatedTrade {
        data = typeof data === 'object' ? data : {};
        let result = new SimulatedTrade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["tradingSymbol"] = this.tradingSymbol;
        data["transactionType"] = this.transactionType;
        data["quantity"] = this.quantity;
        data["entryPrice"] = this.entryPrice;
        data["entryTime"] = this.entryTime ? this.entryTime.toISOString() : <any>undefined;
        data["exitPrice"] = this.exitPrice;
        data["exitTime"] = this.exitTime ? this.exitTime.toISOString() : <any>undefined;
        data["profitLoss"] = this.profitLoss;
        data["status"] = this.status;
        return data;
    }
}

export interface ISimulatedTrade {
    orderId: string | undefined;
    tradingSymbol: string | undefined;
    transactionType: string | undefined;
    quantity?: number;
    entryPrice?: number;
    entryTime?: Date;
    exitPrice?: number;
    exitTime?: Date;
    profitLoss?: number;
    status: string | undefined;
}

export class Strategy implements IStrategy {
    id?: number;
    name!: string;
    description?: string | undefined;
    legs?: Leg[] | undefined;
    executionSettings?: ExecutionSettings;
    brokerLevelSettings?: BrokerLevelSettings;

    constructor(data?: IStrategy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["legs"])) {
                this.legs = [] as any;
                for (let item of _data["legs"])
                    this.legs!.push(Leg.fromJS(item));
            }
            this.executionSettings = _data["executionSettings"] ? ExecutionSettings.fromJS(_data["executionSettings"]) : <any>undefined;
            this.brokerLevelSettings = _data["brokerLevelSettings"] ? BrokerLevelSettings.fromJS(_data["brokerLevelSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Strategy {
        data = typeof data === 'object' ? data : {};
        let result = new Strategy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.legs)) {
            data["legs"] = [];
            for (let item of this.legs)
                data["legs"].push(item ? item.toJSON() : <any>undefined);
        }
        data["executionSettings"] = this.executionSettings ? this.executionSettings.toJSON() : <any>undefined;
        data["brokerLevelSettings"] = this.brokerLevelSettings ? this.brokerLevelSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStrategy {
    id?: number;
    name: string;
    description?: string | undefined;
    legs?: Leg[] | undefined;
    executionSettings?: ExecutionSettings;
    brokerLevelSettings?: BrokerLevelSettings;
}

export class StrategyConfig implements IStrategyConfig {
    id?: string | undefined;
    name!: string | undefined;
    isActive?: boolean;
    allocatedCapital?: number;
    strategyType!: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    riskParameters!: RiskParameters;

    constructor(data?: IStrategyConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.riskParameters = new RiskParameters();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.allocatedCapital = _data["allocatedCapital"];
            this.strategyType = _data["strategyType"];
            if (_data["parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["parameters"]) {
                    if (_data["parameters"].hasOwnProperty(key))
                        (<any>this.parameters)![key] = _data["parameters"][key];
                }
            }
            this.riskParameters = _data["riskParameters"] ? RiskParameters.fromJS(_data["riskParameters"]) : new RiskParameters();
        }
    }

    static fromJS(data: any): StrategyConfig {
        data = typeof data === 'object' ? data : {};
        let result = new StrategyConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["allocatedCapital"] = this.allocatedCapital;
        data["strategyType"] = this.strategyType;
        if (this.parameters) {
            data["parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (<any>data["parameters"])[key] = (<any>this.parameters)[key];
            }
        }
        data["riskParameters"] = this.riskParameters ? this.riskParameters.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStrategyConfig {
    id?: string | undefined;
    name: string | undefined;
    isActive?: boolean;
    allocatedCapital?: number;
    strategyType: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    riskParameters: RiskParameters;
}

export enum TargetSLRefPrice {
    _0 = 0,
    _1 = 1,
}

export class TradingViewAlert implements ITradingViewAlert {
    strategyName?: string | undefined;
    strike?: number;
    type?: string | undefined;
    signal?: string | undefined;
    action?: string | undefined;

    constructor(data?: ITradingViewAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.strategyName = _data["strategyName"];
            this.strike = _data["strike"];
            this.type = _data["type"];
            this.signal = _data["signal"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): TradingViewAlert {
        data = typeof data === 'object' ? data : {};
        let result = new TradingViewAlert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strategyName"] = this.strategyName;
        data["strike"] = this.strike;
        data["type"] = this.type;
        data["signal"] = this.signal;
        data["action"] = this.action;
        return data;
    }
}

export interface ITradingViewAlert {
    strategyName?: string | undefined;
    strike?: number;
    type?: string | undefined;
    signal?: string | undefined;
    action?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

}